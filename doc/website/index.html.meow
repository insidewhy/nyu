!html
head {
    %title nyu - PEG based parser generator
    link(rel=stylesheet, type=text/css, href=css/global.css)
}

!body

%h1 Nyu

#links {
    links:
    %a(href=http://github.com/tuxjay/nyu) source
    %a(href=https://sourceforge.net/projects/nyu/files/) download
    %a(href=#status) status
}

%p { Nyu is a parser generator system with a PEG based input language. Nyu uses | a(href=http://chilon.net/papers/tbpeg.pdf)TBPEG | based PEGs which are capability of creating an AST type from a language grammar, in addition to creating a parser capable of storing data directly to this tree. }

%h2 Using % to parse joined sequences
%pre <<EOF
    @grammar list
    Spacing    <- \s

    // * or + repetitions of a character storing parser store a string.
    IdentifierSuffix <- [0-9a-zA-Z_]*

    // Spacing* is allowed between parsers in a sequence. Spacing* is not
    // allowed between parsers joined with ^.
    // The storage types of adjacent string/char storing parsers joined with ^
    // are collapsed to store a single string, so Identifier stores a string.
    Identifier <- [a-zA-Z_] ^ IdentifierSuffix

    // A % B matches A (B A)* but stores vector[storage type of A]
    // In Grammar "[", "," and "]" are not stored as they  always match the
    // same data.
    Grammar    <- "[" (Identifier % ",") "]"

    // A ^% matches A^(B^A)* i.e. spacing is not allowed before and after the
    // joining parser.

    // stores: vector<string>
    // parses: [ hello, king ]
    // as:     vector<string>("hello", "king")
EOF

%h2 Using / to parse ordered choice and store variant
%pre <<EOF
    @grammar js
    Spacing     <- \s
    Identifier  <- [a-zA-Z_] ^ [0-9a-zA-Z_]*

    // Sequences store tuples.  sub-tuples are broken down into the parent
    // tuple type, and a tuple that stores a single type is broken down into
    // that type.
    // FuncCall stores tuple(string, string).
    FuncCall <- Identifier "(" Identifier ")"

    // FuncCall stores tuple(string, string) and Identifier stores string so
    // Grammar stores vector< variant<string, tuple<string, string> > >
    // Duplicate types are collapsed into a single entry in a variant, and a
    // variant that stores a single type is collapsed to that type.
    Grammar <- (FuncCall / Identifier)+
EOF

%h2 Using &lt;= to create node parsers which store new types
%pre <<EOF
    @grammar mathematics_basic
    Spacing   <- \s

    // <int- stores resulting parsed string as int
    Number    < int - [0-9]+

    // <= creates a "node parser". Node parsers store a new type with the same
    // name as the parsing rule. Types stored by node parsers  cannot be broken
    // down into the storage type of including parsers.
    Product   <= Number %+ "*"

    // %+ is like % but at least one join item must be stored.
    Addition  <= Product %+ "+"
    Grammar   <- Addition+

    // stores: vector<Addition>
    // creates:
    //     class Product {
    //          value_: vector<int>
    //     }
    //     class Addition {
    //          value_: vector<Product>
    //     }
    // parses: 4 + 2
    // as:     [ Addition[Product[4], Product[2]] ]
    // parses: 4
    // as:     [ Addition[Product[4]] ]
    // parses: 4 7
    // as:     [ Addition[Product[4]], Addition[Product[7]]]
EOF

%h2 Node parsers can refer to themselves
%pre <<EOF
    @grammar mathematics_basic
    Spacing    <- \s
    Number     < int - [0-9]+

    // Expression recursively refers to itself through Term. This would not be
    // possible if Expression was not a node parser as in this case the type of
    // Expression would recursively depend on its own storage type.
    // Term stores variant<int, Expression>
    Term       <= Number / "(" Expression ")"
    Product    <= Number %+ "*"
    Addition   <= Product %+ "+"
    Expression <= Addition
    Grammar    <- Expression+
EOF

%h2 "Using |% to recursively collapse unjoined nodes"

%pre <<EOF
    @grammar mathematics
    Spacing   <- \s
    Number    < int - [0-9]+

    // |% parses the same data as %+ but stores parsed data differently.
    // The node type is only created if the join matches more than one item,
    // otherwise it stores the item to the left of the |%. The resulting type
    // of the whole expression is a variant that can store either type.
    // In this case Product stores variant<int, Product> which is populate
    // with the type depending on the data Product parses.
    Product   <= Number  |% "*"

    // node parsers that use |+, |* or |% cannot recursively refer to themselves


    // e.g. Product can store variant<Product, int>
    // Addition stores: variant<Addition, storage type of Product>
    //          expand: variant<Addition, variant<Product, int>>
    //        collapse: variant<Addition, Product, int>
    Addition  <= Product |% "+"

    Grammar   <- Addition+

    // stores: vector< variant<int, Product, Addition> >
    // creates:
    //     class Product {
    //          value_: vector<int>
    //     }
    //     class Addition {
    //          value_: vector<variant<int, Product>>
    //     }
    // parses: 4 + 2
    // as:     [ Addition[4, 2] ]
    // parses: 4
    // as:     [ 4 ]
    // parses: 4 7
    // as:     [ 4, 7 ]
    // parses: 4 + 2 * 7
    // as:     [ Addition[4, Product[2, 7]] ]
EOF

%h2 Further Reading

%p { The syntax of nyu is fully described in the paper on tree building parser expression grammars which can be found | %a(href=http://chilon.net/papers/tbpeg.pdf) "here." }

%h2#status Status

%ul.status {
    %li { .completed completed | Research new notation to extend PEG to include &ldquo;AST-building&rdquo; parsers. Read paper | a(href=http://chilon.net/papers/tbpeg.pdf) TBPEGs }
    %li { .completed completed | chilon::parser, a C++0x implementation of TBPEGs, to be used for C++0x generated parsers. Project website | a(href=http://chilon.net/library.html) chilon::parser }
    %li { .completed completed | nyu parser written in nyu. }
    %li { .completed completed | nyu parser in chilon::parser to be used for bootstrapping the above parser. }
    %li { .inprogress in progress | C++0x chilon::parser output. }
    %li { .yettostart yet to start | javascript parser output for use in live nyu demo on website. }
    %li { .yettostart yet to start | More output languages: java, ruby, C, C++ as boost::spirit. }
}

%h2 Contributing

%div Wanted: Code for more output languages, suggestions and art for the website.
%div E-mail: nyu (@) chilon.net.
%div { IRC Channel: #nyah on | %a(href=irc://irc.freenode.net/nyah) "irc.freenode.net" }
