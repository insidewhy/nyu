!html
head {
    %title nyu - PEG based parser generator
    link(rel=stylesheet, type=text/css, href=css/global.css)
}

!body

%h1 Nyu

#links {
    links:
    %a(href=http://github.com/tuxjay/nyu) source
    %a(href=https://sourceforge.net/projects/nyu/files/) download
    %a(href=#status) status
}

%p { Nyu is a parser generator system with a PEG based input language. Nyu uses | a(href=http://chilon.net/papers/tbpeg.pdf)TBPEG | based PEGs which are capability of creating an AST type from a language grammar, in addition to creating a parser capable of storing data directly to this tree. }

%h2 Using % to parse joined sequences
%pre <<EOF
    @grammar list
    Spacing    <- \s

    // Spacing allowed between elements in a sequence, ^ disallows spacing.
    // The storage types of adjacent string/char storing items joined with ^
    // are collapsed to store a single string, so Identifier stores a string.
    Identifier <- [a-zA-Z_] ^ [0-9a-zA-Z_]*

    // % Joins identifier with a comma. Spacing can be around join (^% disallows this).
    Grammar    <- "[" (Identifier % ",") "]"

    // stores: vector<string>
    // parses: [ hello, king ]
    // as:     vector<string>("hello", "king")
EOF

%h2 Using / to parse order choice and store variant
%pre <<EOF
    @grammar js
    Spacing    <- \s
    Identifier     <- [a-zA-Z_] ^ [0-9a-zA-Z_]*

    // Spacing is optional between items in a sequence, so blah( blah )
    // and blah(blah) both match. "(" always parses the same thing so by
    // default does not store anything in the parse tree. FuncCall stores
    // tuple(string, string)
    FuncCall <- Identifier "(" Identifier ")"

    // FuncCall stores string, and Identifier stores tuple(string, string) so
    // the grammar stores vector< variant<string, tuple<string, string> > >
    Grammar <- (FuncCall / Identifier)+
EOF

%h2 Using &lt;= to create types
%pre <<EOF
    @grammar mathematics_basic
    Spacing   <- \s

    // <int- stores resulting parsed string as int
    Number    < int - [0-9]+

    // <= creates a new type, the storage type of these rules aren't
    // collapsed into those of parent expressions.
    Product   <= Number %+ "*"

    // %+ is like % but at least one join item must be stored.
    Addition  <= Product %+ "+"
    Grammar   <- Addition+

    // stores: vector<Addition>
    // creates:
    //     class Product {
    //          value_: vector<int>
    //     }
    //     class Addition {
    //          value_: vector<Product>
    //     }
    // parses: 4 + 2
    // as:     [ Addition[Product[4], Product[2]] ]
    // parses: 4
    // as:     [ Addition[Product[4]] ]
    // parses: 4 7
    // as:     [ Addition[Product[4]], Addition[Product[7]]]
EOF

%h2 &lt;= rules can refer to themselves
%pre <<EOF
    @grammar mathematics_basic
    Spacing    <- \s

    Number     < int - [0-9]+
    // because Expression stores a new type (as dictated by <=) it can
    // recursively refer to itself through Term. This would not be possible
    // if Expression was not a node storing rule as in this case deducing the
    // type of term would cause an infinite recursion. <= types that use
    // |+, |* or |% cannot recursively refer to themselves.
    Term       <= Number / Expression
    Product    <= Number %+ "*"
    Addition   <= Product %+ "+"
    Expression <= Addition
    Grammar   <- Expression+
EOF

%h2 "Using |% to recursively collapse unjoined nodes"
%pre <<EOF
    @grammar mathematics
    Spacing   <- \s
    Number    < int - [0-9]+

    // |% parses the same data as %+ but stores parsed data differently.
    // The node is only created if the join matches more than one item, otherwise
    // it stores the item to the left of the |%. The resulting type of the whole
    // expression is a variant that can store either type.
    // In this case Product stores variant<int, Product>
    Product   <= Number  |% "*"


    // The types in the variant of Product are collapsed into the storage of
    // Addition's variant.
    // e.g. Product can store variant<Product, int>
    // Addition stores: variant<Addition, storage type of Product>
    //          expand: variant<Addition, variant<Product, int>>
    //        collapse: variant<Addition, Product, int>

    Addition  <= Product |% "+"

    Grammar   <- Addition+

    // stores: vector< variant<int, Product, Addition> >
    // creates:
    //     class Product {
    //          value_: vector<int>
    //     }
    //     class Addition {
    //          value_: vector<variant<int, Product>>
    //     }
    // parses: 4 + 2
    // as:     [ Addition[4, 2] ]
    // parses: 4
    // as:     [ 4 ]
    // parses: 4 7
    // as:     [ 4, 7 ]
    // parses: 4 + 2 * 7
    // as:     [ Addition[4, Product[2, 7]] ]
EOF

%h2 Further Reading

%p { The syntax of nyu is fully described in the paper on tree building parser expression grammars which can be found | %a(href=http://chilon.net/papers/tbpeg.pdf) "here." }

%h2#status Status

%ul.status {
    %li { .completed completed | Research new notation to extend PEG to include &ldquo;AST-building&rdquo; parsers. Read paper | a(href=http://chilon.net/papers/tbpeg.pdf) TBPEGs }
    %li { .completed completed | chilon::parser, a C++0x implementation of TBPEGs, to be used for C++0x generated parsers. Project website | a(href=http://chilon.net/library.html) chilon::parser }
    %li { .completed completed | nyu parser written in nyu. }
    %li { .completed completed | nyu parser in chilon::parser to be used for bootstrapping the above parser. }
    %li { .inprogress in progress | C++0x chilon::parser output. }
    %li { .yettostart yet to start | javascript parser output for use in live nyu demo on website. }
    %li { .yettostart yet to start | More output languages: java, ruby, C, C++ as boost::spirit. }
}

%h2 Contributing

%div Wanted: Code for more output languages, suggestions and art for the website.
%div E-mail: nyu (@) chilon.net.
%div { IRC Channel: #nyah on | %a(href=irc://irc.freenode.net/nyah) "irc.freenode.net" }
